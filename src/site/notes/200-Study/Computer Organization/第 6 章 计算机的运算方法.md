---
{"dg-publish":true,"permalink":"/200-Study/Computer Organization/第 6 章 计算机的运算方法/","noteIcon":""}
---


# 第 6 章 计算机的运算方法

# 6.1 无符号数和有符号数

## 6.1.1 无符号数

寄存器的位数反映无符号数的表示范围

8 位寄存器：0 ~ 255；16 位寄存器：0 ~ 65535

## 6.1.2 有符号数

### 机器数与真值

真值：带数学符号的数；机器数：符号数字化的数（无小数点，而是已规定方式隐含小数点），0 表示正，1 表示符号。

### 原码表示法

1. 原码的定义
    1. 整数，设 x 为真值，n 为数值位的位数，

        $$
        [x]_原 =
        \begin{cases}
        0,x & 2^n \ {\color{red}{>}} \ x \  {\color{red}\ge} \ 0 \\
        2^n - x &  0 \ {\color{red}\ge} \ x \ {\color{red}{>}} \ -2^n \\    \end{cases}
        $$

    2. 小数，设 x 为真值，n 为小数位的位数，

        $$
        [x]_原 =
        \begin{cases}
        x & 1 \ {\color{red}{>}} \ x \  {\color{red}\ge} \ 0 \\
        1 - x &  0 \ {\color{red}\ge} \ x \ {\color{red}{>}} \ -1 \\    \end{cases}
        $$

    $[+0]_原$ 不等于 $[-0]_原$，即原码中的 0 表示形式有两种 $[+0]_原 =0,0000$，$[-0]_原 = 1,0000$。

### 补码表示法

1. 结论：
    - 一个负数加上“模”即得该负数的补数。
    - 一个正数和一个负数互为补数时，它们绝对值之和即为模数。

    ![CO_6_01](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_01.png)

2. 正数的补数即为其本身

    ![CO_6_02](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_02.png)

3. 补码的定义
    1. 整数，设 x 为真值，n 为数值位的位数，

        $$
        [x]_补 =
        \begin{cases}
        0,x & 2^n \ {\color{red}{>}} \ x \  {\color{red}\ge} \ 0 \\
        2^{n+1} + x &  0 \ {\color{red}>} \ x \ {\color{red}\ge} \ -2^n \ (mod \ 2^{n+1}) \\    \end{cases}
        $$

    2. 小数，设 x 为真值，n 为小数位的位数，

        $$
        [x]_补 =
        \begin{cases}
        x & 1 \ {\color{red}{>}} \ x \  {\color{red}\ge} \ 0 \\
        2 + x &  0 \ {\color{red}>} \ x \ {\color{red}\ge} \ -1 \ (mod \  2)\\    \end{cases}
        $$

    $[+0]_补$ 等于 $[-0]_补$，即补码中的 0 表示形式相同 $[+0]_补 = [-0]_补 = 0,0000$。

    $[-1]_补 = 2 + x = 10.0000 - 1.0000 = 1.0000， -1 \ 无原码$

4. 原码转补码：正数补码等于原码；负数补码为原码的符号位不变，末位取反加一。补码转原码方法相同。

    负数原码转补码另一条规律：符号位不变，数值位从低位到高位中，第一个 1 及其后面的 0 保持不变，第一个 1 后的数值位取反。

5. 已知 $[y]_补$ 求 $[-y]_补$：$[y]_补$ 连同符号位在内，每位取反，末位加 1，即得 $[-y]_补$。

    ![CO_6_03](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_03.png)

### 反码表示法

1. 反码的定义
    1. 整数，设 x 为真值，n 为数值位的位数，

        $$
        [x]_反 =
        \begin{cases}
        0,x & 2^n \ {\color{red}{>}} \ x \  {\color{red}\ge} \ 0 \\
        (2^{n+1} - 1) + x &  0 \ {\color{red}\ge} \ x \ {\color{red}>} \ -2^n \ (mod \ 2^{n+1} - 1) \\    \end{cases}
        $$

    2. 小数，设 x 为真值，n 为小数位的位数，

        $$
        [x]_反 =
        \begin{cases}
        x & 1 \ {\color{red}{>}} \ x \  {\color{red}\ge} \ 0 \\
        (2 - 2^{-n}) + x &  0 \ {\color{red}\ge} \ x \ {\color{red}>} \ -1 \ \ (mod \ 2 - 2^{-n})\\    \end{cases}
        $$

    $[+0]_反$ 不等于 $[-0]_反$，即反码中的 0 表示形式有两种 $[+0]_反 =0,0000$，$[-0]_反 = 1,1111$。

    $[-1]_补 = 2 + x = 10.0000 - 1.0000 = 1.0000， -1 \ 无原码$

2. 原码转反码：正数反码同原码；负数符号位不变，剩余各位取反。

### 原码、补码、反码真值范围

![CO_6_04](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_04.png)

### 移码表示法

补码表示很难直接判断其真值大小，用移码表示能够直接反映真值大小。移码通常用于表示浮点数的阶数部分，故移码只表示整数。

1. 移码的定义：设 x 为真值，n 为整数的位数，无论正负 $[x]_移 =2^n + x \ (2^n > x \ge {-2^n})$

    $[+0]_移$ 等于 $[-0]_移$，即移码中的 0 表示形式相同 $[+0]_移 = [-0]_移 = 1,0000$。

    当 n = 5 时，最小真值为 $-2^5 = -100000$，$[-100000]_移 = 2^5 - 100000 = 00000$。由此可见，最小真值的移码为全 0

![CO_6_05](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_05.png)

1. 移码和补码的比较：补码与移码只差一个符号位，即符号位取反。
2. 真值、补码和移码的对照表

    ![CO_6_06](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_06.png)

# 6.2 数的定点表示和浮点表示

## 6.2.1 定点表示

1. 概念

    定点数分为数符和数值两部分组成，小数点按约定方式标出。根据小数点位置可将定点机分为小数定点机和整数定点机。小数点位置在数符后的定点机称为小数定点机，小数点位置在数值末尾的定点机称为整数定点机。

2. 表示范围

    ![CO_6_07](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_07.png)

## 6.2.2 浮点表示

- 为什么要引入浮点数表示
    - 定点表示编程困难，程序员要调节小数点的位置
    - 数的表示范围小，为了能表示两个大小相差很大的数据，需要很长的机器字长
    - 数据存储单元的利用率往往很低

$$
N = S \times r^j \ 浮点数的一般形式\\
S表示尾数，j表示阶码，r表示尾数的基值
$$

![CO_6_08](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_08.png)

### 浮点数的表示形式

![CO_6_09](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_09.png)

### 浮点数的表示范围

![CO_6_10](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_10.png)

![CO_6_11](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_11.png)

### 浮点数的规格化形式

r = 2，尾数最高位为 1

r = 4，尾数最高 2 位不全为 0

r = 8，尾数最高 3 位不全为 0

结论：基数不同，浮点数的规格化形式不同。

### 浮点数的规格化

r = 2，左规，尾数左移 1 位，阶码减 1；右规，尾数右移 1 位，阶码加 1。

r = 4，左规，尾数左移 2 位，阶码减 1；右规，尾数右移 2 位，阶码加 1。

r = 8，左规，尾数左移 3 位，阶码减 1；右规，尾数右移 3 位，阶码加 1。

结论：基数 r 越大，可表示的浮点数范围越大，浮点数的精度越低。

![CO_6_12](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_12.png)

- 机器零的处理
    - 当浮点数尾数为 0 时，不论其阶码为何值，按机器零处理。
    - 当浮点数阶码等于或小于它所表示的最小数时，不论尾数为何值，按机器零处理。

## 6.2.3 定点数与浮点数的比较

1. 当浮点机和定点机的位数相同时，浮点数的表示范围比定点数大得多。
2. 当浮点数为规格化数时，其相对精度远比定点数高。
3. 浮点数运算要分阶码部分和尾数部分，而且运算结果都要求规格化，故浮点运算步骤比定点运算步骤多，运算速度比定点运算低，运算线路比定点运算复杂。
4. 在溢出判断的方法上，浮点数是对规格化数的阶码进行判断，而定点数时对数值本身进行判断。

## 6.2.4 举例

书上例题

## 6.2.5 IEEE 754 标准

![CO_6_13](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_13.png)

# 6.3 定点运算

## 6.3.1 移位运算

1. 移位运算的数学意义

机器用语中的左移和右移操作对象是数值而小数点不动，左移绝对值扩大，右移绝对值缩小。

1. 算术移位规则

    符号位不变

    ![CO_6_14](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_14.png)

2. 算术移位的硬件实现

    ![CO_6_15](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_15.png)

3. 算术移位与逻辑移位的区别

![CO_6_16](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_16.png)

## 6.3.2 加减法运算

1. 补码加减法运算的公式
    - 加法
        1. 整数：$[A]_补 + [B]_补 = [A + B]_补 \ （mod \ 2^{n + 1})$
        2. 小数：$[A]_补 + [B]_补 = [A + B]_补 \ （mod \ 2)$
    - 减法
        1. 整数：$[A - B]_补 = [A + (-B)]_补 = [A]_补 + [-B]_补 \ (mod \ 2^{n+1})$
        2. 小数：$[A - B]_补 = [A + (-B)]_补 = [A]_补 + [-B]_补 \ (mod \ 2)$

    连同符号位一起相加，符号位产生的进位自然丢掉。

2. 溢出判断
    1. 一位符号位判断溢出

        参加操作的两个数（减法时即为被减数和“求补”以后的减数）符号相同，其结果的符号与原操作数的符号不同，即为溢出。

        硬件实现：最高有效位的进位 $\bigoplus$ 符号位的进位 = 1，溢出

        ![CO_6_17](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_17.png)

    2. 两位符号位判断溢出

        $[x]_{补'} =
        \begin{cases}
        x & 1 \ {\color{red}{>}} \ x \  {\color{red}\ge} \ 0 \\
        4 + x &  0 \ {\color{red}>} \ x \ {\color{red}\ge} \ -1 \ (mod \  4)\\    \end{cases}$

        $[x]_{补'} + [y]_{补'} = [x + y]_{补'} \ (mod \ 4)$

        $[x - y]_{补'} = [x]_{补'} + [-y]_{补'} \ (mod \ 4)$

        结果的双符号位相同，则未溢出；结果的双符号位不同，则溢出，最高符号位代表其正真的符号位。

3. 补码加减法的硬件配置

    ![CO_6_18](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_18.png)

## 6.3.3 乘法运算

1. 笔算乘法的分析

![CO_6_19](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_19.png)

1. 笔算乘法的改进

    ![CO_6_20](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_20.png)

    总结：

    - 乘法运算可用加法和移位实现，n = 4，加 4 次，移 4 次
    - 由乘数的末位决定被乘数是否与原部分积相加，然后右移一位形成新的部分积，同时乘数右移一位（末位移丢），空出高位存放部分积的低位。
    - 被乘数只与部分积的高位相加
    - 硬件：3 个寄存器，其中 2 个具有移位功能，1 个全加器。
2. 原码的乘法运算
    - 原码一位乘法运算规则（以小数为例）

        设 $[x]_原 = x_0.x_1 x_2 …x_n$

        $[y]_原 = y_0.y_1 y_2 …y_n$

        $[x \cdot y]_原 = (x_0 \bigoplus y_0).(0.x_1x_2…x_n)(0.y_1y_2…y_n) = (x_0 \bigoplus y_0).x^*y^*$

        式中 $x^* = 0.x_1x_2…x_n$ 为 x 的绝对值，$y^* = 0.y_1y_2…y_n$ 为 y 的绝对值

        乘积的符号位单独处理 $x_0 \bigoplus y_0$，数值部分为绝对值相乘 $x^* \cdot y^*$

    - 原码一位乘法递推公式

        $$
        \begin{align}
            x^* \cdot y^* & = x^*(0.y_1y_2...y_n) \\
                          & = x^*(y_1 2^{-1} + y_2 2^{-2} + \cdots + y_n2^{-n}) \\
                          & = 2^{-1}(y_1x^* + 2^{-1}(y_2x^* + \cdots 2^{-1}(y_nx^* + 0) \cdots))
        \end{align}
        $$

        ![CO_6_21](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_21.png)

    - 特点：绝对值运算，用移位的次数判断乘法是否结束，逻辑移位（包括符号位一起移位）
    - 原码一位乘法的硬件配置

        ![CO_6_22](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_22.png)

3. 补码的乘法运算

## 6.3.4 除法运算

1. 原码除法（以小数为例）

    设 $[x]_原 = x_0.x_1 x_2 …x_n$

    $[y]_原 = y_0.y_1 y_2 …y_n$

    $[\frac x y]_原 = (x_0 \bigoplus y_0).(0.x_1x_2…x_n)(0.y_1y_2…y_n) = (x_0 \bigoplus y_0).\frac {x^*} {y^*}$

    式中 $x^* = 0.x_1x_2…x_n$ 为 x 的绝对值，$y^* = 0.y_1y_2…y_n$ 为 y 的绝对值

    乘积的符号位单独处理 $x_0 \bigoplus y_0$，数值部分为绝对值相乘 $\frac {x^*} {y^*}$

    约定：

    1. 小数定点除法 ${x^*} < {y^*}$，保证商小于 1
    2. 整数定点除法 ${x^*} > {y^*}$，保证商大于 1
    3. 被除数不等于 0，除数不能为 0
2. 原码恢复余数法

    特点：当余数为负时，需加上余数，将其恢复成原来的余数。

    ![CO_6_23](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_23.png)

    对于第一次上商，如果是小数除法，商必须为 0；如果是整数除法，商必须为 1。

3. 原码不恢复余数法（加减交替法）
    - 恢复余数法运算规则
        - 余数 $R_i > 0$ 上商 1，再对 $R_i$ 左移一位后减除数，即 $2R_i - y^*$。
        - 余数 $R_i < 0$ 上商 0，$R_i + y^*$ 恢复余数，再做 $2(R_i + y^*) - y^*$，即 $2R_i + y^*$。
    - 不恢复余数法运算规则
        - 余数 $R_i > 0$ 上商 1，做 $2R_i - y^*$ 的运算。
        - 余数 $R_i < 0$ 上商 0，做 $2R_i + y^*$ 的运算。

    ![CO_6_24](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_24.png)

    特点：上商 n + 1 次，第一次上商判断是否溢出，逻辑左移 n 次，加 n + 1 次，用移位的次数判断除法是否结束。

    - 原码加减交替除法硬件配置

        ![CO_6_25](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_25.png)

4. 补码除法

# 6.4 浮点四则运算

## 6.4.1 浮点数的加减运算

设 $x = S_x \cdot 2^{j_x}，y = S_y \cdot 2^{j_y}$

运算步骤：

1. 对阶，使两数的小数点位置对齐。
    1. 求阶差

        ![CO_6_26](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_26.png)

    2. 对阶原则：小阶向大阶看齐，防止尾数溢出。
2. 尾数求和，将对阶后的两尾数按定点加法运算规则求和（差）。
3. 规格化，为增加有效数字的位数，提高运算精度，必须将求和（差）后的尾数规格化。
    1. 规格化的定义：$r = 2,\ {1 \over 2} \le |S| < 1$
    2. 规格化数的判断

        $S > 0$，真值：$0.1xx\cdots x$，原码：$0.1xx\cdots x$，补码：$0.1xx\cdots x$，反码：$0.1xx\cdots x$

        $S < 0$，真值：$-0.1xx\cdots x$，原码：$1.1xx\cdots x$，补码：$1.0xx\cdots x$，反码：$1.0xx\cdots x$

        对于原码，不论正数、负数，规格化后第一位数为 1

        对于补码，规格化后符号位和第一数位不同

        $S = -{1 \over 2} = -0.100 \cdots 0$，$[S]_原 = 1.100 \cdots 0$，$[S]_补 = 1.100 \cdots 0$，因此 $[-{1 \over 2}]_补$ 不是规格化数。

        $S = -1$，无原码形式，$[S]_补 = 1.000 \cdots 0$，因此 $[-1]_补$ 是规格化数。

    3. 规格化的方法

        左规：尾数左移一位，阶码减一，直到数符和第一数位不同为止

        右规：尾数右移一位，阶码加一；当尾数溢出（ > 1）时，需要右规

4. 舍入，在对阶和右规过程中，可能出现尾数末位丢失而引起误差，需考虑舍入
    1. 直接丢弃
    2. 0 舍 1 入法：类似十进制中的“四舍五入”法，即在尾数右移时，被移去的最高数位为 0 则舍去，为 1 则末位加 1。可能使尾数溢出，此时需要再做一次右规。
    3. 恒置 1 法
5. 溢出判断，即判断结果是否溢出。

    设机器数为补码，尾数为规格化形式，并假设阶符取 2 位，阶码的数值部分取 7 位，数符取 2 位，尾数取 n 位，则该补码在数轴上的表示为

    ![CO_6_27](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_27.png)

## 6.4.2 浮点的乘除法运算

# 6.5 算术逻辑单元

## 6.5.1 ALU 电路

![CO_6_28](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_28.png)

## 6.5.2 快速进位链

### 并行加法器

![CO_6_29](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_29.png)

$$
S_i = \overline{A_i B_i} C_{i-1} + \overline{A_i} B_i \overline{C_{i-1}} + A_i \overline{B_iC_{i-1}} + A_i B_i C_{i-1} \\
C_i = \overline{A_i} B_i C_{i-1} + A_i \overline{B_i}C_{i-1} + A_i B_i \overline{C_{i-1}} + A_i B_i C_{i-1} = A_i B_i + (A_i + B_i)C_{i-1}
$$

$d_i = A_i + B_i$ 本地进位，$t_i = A_i + B_i$ 传送条件，则 $C_i = d_i + t_i C_{i-1}$

### 串行进位链

传送进位的电路称之为进位链；串行进位链是指并行加法器中的进位信号采用串行传递。

![CO_6_30](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_30.png)

### 并行进位链

并行进位链是指并行加法器中的进位信号是同时产生的，又称先行进位、跳跃进位。通常并行进位链又单重分组和双重分组两种实现方案。

![CO_6_31](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_31.png)

1. 单重分组跳跃进位链

    单重分组跳跃进位就是将 n 位全加器分成若干小组，小组内的进位同时产生，小组与小组之间采用串行进位，这种进位又有组内并行、组间串行之称。

    单重分组方案进位时间仅为串行进位链的 1/3，但随着 n 的增大，其优势便会很快减弱。

    ![CO_6_32](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_32.png)

2. 双重分组跳跃进位链

    双重分组跳跃进位链就是将 n 位全加器分成若干大组，每个大组中又包含若干小组，而每个大组内包含的各个小组的最高进位是同时产生的，大组与大组间采用串行进位。

    因各小组最高进位是同时形成的，小组内的其他进位也是同时形成的（注意：小组内的其他进位与小组的最高位进位并不是同时产生的），故又有组（小组）内并行、组（小组）间并行之称。

    ![CO_6_33](https://image-1256466424.cos.accelerate.myqcloud.com/CO_6_33.png)
